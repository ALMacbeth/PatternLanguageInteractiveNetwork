<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Network (Static Layered by Section → Subsection)</title>
  <style>
    :root {
      --panel-max: 1200px; /* fits typical desktop/laptop screens */
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 0;
      padding: 16px;
      background: #fafafa;
    }

    #chart {
      width: min(var(--panel-max), 95vw);
      margin: 0 auto;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      padding: 8px;
      position: relative;
      overflow: visible; /* ensure labels never clip */
    }

    .caption {
      width: min(var(--panel-max), 95vw);
      margin: 10px auto 0;
      color: #555;
      font-size: 14px;
      text-align: center;
    }

    .tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      line-height: 1.3;
      white-space: nowrap;
      transform: translate(-50%, -120%);
      z-index: 10;
      box-shadow: 0 4px 12px rgba(0,0,0,0.25);
    }

    .layer-label {
      font-size: 11px;
      fill: #555;
    }

    .sublayer-rule {
      stroke: #eee;
      stroke-width: 1;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
</head>

<body>
  <h1 style="text-align:center; font-weight:600; margin-bottom:12px;">
    A Pattern Language as Directed Hierarchical Network
  </h1>

  <div id="chart"></div>

    <p id="caption"> Click a node to highlight neighbors; click background to reset. Hover a node for details. </p>

    <section>
      <h2>Project Description</h2>
      <p>
        This interactive visualisation reinterprets <em>A Pattern Language</em> as a directed hierarchical network,
        allowing users to explore how patterns interact across scales—from buildings and streets to cities and regions.
        By transforming the original text into a network model, the tool makes the nested structure of the language
        easier to understand, navigate, and query.
      </p>
      <p>
        It functions as both a teaching and analytical tool that can enable
        comparisons between cities and revealing how  urban forms align with or diverge from Alexander’s spatial logic.
        This approach supports future research by linking expert knowledge with data-informed analysis of cities as Complex Adaptive Systems.
      </p>
    
      <h3>Acknowledgements</h3>
      <p>
        Special thanks to <strong>Beka Westberg</strong> for sharing the original dataset that made this project possible.<br>
        Link: <a href="http://bekawestberg.me/blog/pattern-language/" target="_blank">http://bekawestberg.me/blog/pattern-language/</a>
      </p>

      <h3>Features</h3>
      <ul>
        <li>Explore hierarchical relationships between spatial patterns</li>
        <li>Visualise nested layers interactively</li>
        <li>Useful for urban analysis, design education, and research</li>
      </ul>

      <h3>Created by Mahmud Tantoush</h3>
      <ul>
        <li>Explore hierarchical relationships between spatial patterns</li>
        <li>Visualise nested layers interactively</li>
        <li>Useful for urban analysis, design education, and research</li>
      </ul>
      
      <h3>Created by Mahmud Tantoush</h3>
      <ul>
        <li>Website: <a href="https://www.mahmudtantoush.com/">mahmud.tantoush.com</a></li>
        <li>This paper forms part of a research paper currently in progress.
        <li>GitHub source of the network (code and data available): <a href="https://github.com/mahmud-tantoush/PatternLanguageInteractiveNetwork">https://github.com/mahmud-tantoush/PatternLanguageInteractiveNetwork</a>
      </ul>

    </section>

  <script>
    // ---------- CONFIG ----------
    const PRIMARY_BY = "section";
    const SECONDARY_BY = "subsection";
    const SECTION_ORDER = ["TOWNS", "BUILDINGS", "CONSTRUCTION"];
    const SUBSECTION_ORDER = null;
    const SORT_IN_SUBLAYER = (a, b) => d3.ascending(+a.stars || 0, +b.stars || 0);

    // Adjusted dimensions for standard screen
    const WIDTH = Math.min(1200, window.innerWidth * 0.95);
    const HEIGHT = Math.min(700, window.innerHeight * 0.8);
    const MARGIN_X = 250;  
    const MARGIN_Y = 60;
    const SECTION_GAP = 24;  
    const SUBLAYER_GAP = 12;

    (async function () {
      const data = await fetch("data.json").then(r => r.json());

      // Normalize
      for (const n of data.nodes) {
        n.id = String(n.id);
        n.stars = String(Number(n.stars) + 1);
      }
      for (const l of data.links) {
        l.source = String(l.source);
        l.target = String(l.target);
      }

      const nodes = data.nodes.map(d => ({ ...d }));
      const links = data.links.map(d => ({ ...d }));

      // Equal-height layout across sections
      layoutSectionSubsection(nodes, {
        width: WIDTH,
        height: HEIGHT,
        marginX: MARGIN_X,
        marginY: MARGIN_Y,
        sectionField: PRIMARY_BY,
        subsectionField: SECONDARY_BY,
        sectionOrder: SECTION_ORDER,
        subsectionOrder: SUBSECTION_ORDER,
        sortInSublayer: SORT_IN_SUBLAYER,
        sectionGap: SECTION_GAP,
        sublayerGap: SUBLAYER_GAP,
        equalSectionHeight: true
      });

      const nodeById = new Map(nodes.map(d => [d.id, d]));
      const linkLayout = links.map(l => ({ ...l, s: nodeById.get(l.source), t: nodeById.get(l.target) }));

      // ---------- SCALES ----------
      const color = d3.scaleOrdinal(d3.schemeCategory10);
      const radiusScale = d3.scaleSqrt()
        .domain(d3.extent(nodes, d => +d.stars || 1))
        .range([5, 14]);

      const svg = d3.select("#chart")
        .append("svg")
        .attr("width", WIDTH)
        .attr("height", HEIGHT)
        .attr("viewBox", `0 0 ${WIDTH} ${HEIGHT}`)
        .attr("style", "width:100%; height:auto; display:block; background:#fff; overflow:visible;");

      drawGuides(svg, nodes, {
        width: WIDTH,
        marginX: MARGIN_X,
        sectionField: PRIMARY_BY,
        subsectionField: SECONDARY_BY
      });

      svg.append("defs").selectAll("marker")
        .data(["arrow"])
        .join("marker")
        .attr("id", d => d)
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 12)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .attr("fill", "#999");

      // Helper: line endpoint on circle edge
      function pointOnCircleEdge(cx, cy, r, tx, ty, pad = 0) {
        const dx = tx - cx, dy = ty - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const k = (r + pad) / dist;
        return [cx + dx * k, cy + dy * k];
      }

      // ---------- LINKS ----------
      const link = svg.append("g")
        .attr("stroke", "#999")
        .attr("stroke-opacity", 0.6)
        .selectAll("line")
        .data(linkLayout)
        .join("line")
        .attr("stroke-width", d => Math.sqrt(d.value || 1))
        .attr("x1", d => pointOnCircleEdge(d.s.x, d.s.y, radiusScale(+d.s.stars || 1), d.t.x, d.t.y)[0])
        .attr("y1", d => pointOnCircleEdge(d.s.x, d.s.y, radiusScale(+d.s.stars || 1), d.t.x, d.t.y)[1])
        .attr("x2", d => pointOnCircleEdge(d.t.x, d.t.y, radiusScale(+d.t.stars || 1), d.s.x, d.s.y)[0])
        .attr("y2", d => pointOnCircleEdge(d.t.x, d.t.y, radiusScale(+d.t.stars || 1), d.s.x, d.s.y)[1])
        .attr("marker-end", "url(#arrow)");

      // ---------- NODES ----------
      const node = svg.append("g")
        .attr("stroke", "#fff")
        .attr("stroke-width", 1)
        .selectAll("circle")
        .data(nodes)
        .join("circle")
        .attr("r", d => radiusScale(+d.stars || 1))
        .attr("fill", d => color(d[PRIMARY_BY]))
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .style("cursor", "pointer");

      // Tooltip
      const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);

      const clean = v => (v == null || v === "") ? "—" : v;

      node.on("mouseover", (event, d) => {
        tooltip
          .style("opacity", 1)
          .html(`<strong>${clean(d.name ?? d.id)}</strong><br>
            section: ${clean(d.section)}<br>
            subsection: ${clean(d.subsection)}<br>
            pattern Number: ${clean(d.id)}<br>
            stars: ${clean(d.stars)}`);
      })
      .on("mousemove", (event) => {
        tooltip
          .style("left", event.pageX + "px")
          .style("top",  event.pageY + "px");
      })
      .on("mouseout", () => tooltip.style("opacity", 0));

      // Highlight & reset
      const neighbors = new Map(nodes.map(n => [n.id, new Set()]));
      links.forEach(l => {
        neighbors.get(l.source)?.add(l.target);
        neighbors.get(l.target)?.add(l.source);
      });

      let selectedNode = null;

      node.on("click", (event, d) => {
        event.stopPropagation();
        if (selectedNode && selectedNode.id === d.id) resetHighlight();
        else highlight(d);
      });

      svg.on("click", () => resetHighlight());

      function highlight(d) {
        selectedNode = d;
        const nbrs = neighbors.get(d.id) || new Set();
        node.attr("opacity", n => (n.id === d.id || nbrs.has(n.id)) ? 1 : 0.15)
            .attr("stroke-width", n => (n.id === d.id ? 2 : 1));
        link.attr("opacity", l => (l.source === d.id || l.target === d.id) ? 1 : 0.15);
      }

      function resetHighlight() {
        selectedNode = null;
        node.attr("opacity", 1).attr("stroke-width", 1);
        link.attr("opacity", 0.6);
      }

      // ---------- GUIDES ----------
      function drawGuides(svg, nodes, { width, marginX, sectionField, subsectionField }) {
        const g = svg.append("g");
        const secKey = n => String(n[sectionField] ?? "").toUpperCase();
        const subKey = n => String(n[subsectionField] ?? "").toUpperCase();
        const bySection = d3.group(nodes, secKey);

        for (const [sec, arr] of bySection) {
          const bySub = d3.group(arr, subKey);

          // SECTION LABELS (on the right)
          const allYs = arr.map(d => d.y);
          const secTop = d3.min(allYs);
          const secBottom = d3.max(allYs);
          const secMid = (secTop + secBottom) / 2;

          g.append("text")
            .attr("class", "layer-label")
            .attr("x", width - marginX + 15)
            .attr("y", secMid + 4)
            .attr("text-anchor", "start")
            .attr("font-weight", "600")
            .text(sec);

          // SUBSECTION LINES + LABELS (on the left)
          for (const [sub, subNodes] of bySub) {
            const y = d3.mean(subNodes, d => d.y);

            g.append("line")
              .attr("class", "sublayer-rule")
              .attr("x1", marginX - 8)
              .attr("x2", width - marginX)
              .attr("y1", y)
              .attr("y2", y);

            g.append("text")
              .attr("class", "layer-label")
              .attr("x", marginX - 14)
              .attr("y", y + 4)
              .attr("text-anchor", "end")
              .text(sub);
          }
        }
      }
    })();

    // ---------- LAYOUT ----------
    function layoutSectionSubsection(nodes, {
  width, height,
  marginX = 40, marginY = 40,
  sectionField = "section",
  subsectionField = "subsection",
  sectionOrder = null,
  subsectionOrder = null,
  sortInSublayer = null,
  sectionGap = 24,   // vertical gap between sections
  sublayerGap = 8,
}) {
  const norm = v => String(v ?? "").toUpperCase();
  const sectionOf = n => norm(n[sectionField]);
  const subOf = n => norm(n[subsectionField]);

  // --- 1. Get ordered sections
  let sections = Array.from(new Set(nodes.map(sectionOf)));
  if (sectionOrder && Array.isArray(sectionOrder)) {
    const want = sectionOrder.map(norm);
    sections = want.filter(s => sections.includes(s));
  }

  // --- 2. Compute total number of subsections (lines)
  const sectionGroups = d3.group(nodes, sectionOf);
  const totalSubs = d3.sum(sections, sec => {
    const arr = sectionGroups.get(sec) || [];
    return new Set(arr.map(subOf)).size;
  });

  // --- 3. Compute total available height minus section gaps
  const usableH = height - 2 * marginY - sectionGap * (sections.length - 1);
  const rowGap = usableH / (totalSubs - 1);

  // --- 4. Assign Y positions with extra section gaps
  const posMap = new Map();
  let currentY = marginY;
  for (const sec of sections) {
    const arr = sectionGroups.get(sec) || [];
    let sublayers = Array.from(new Set(arr.map(subOf)));
    if (subsectionOrder instanceof Map && subsectionOrder.has(sec)) {
      const order = subsectionOrder.get(sec).map(norm);
      sublayers = order.filter(s => sublayers.includes(s));
    }
    if (sublayers.length === 0) sublayers = ["__ONLY__"];

    sublayers.forEach((sub, i) => {
      posMap.set(`${sec}__${sub}`, currentY);
      currentY += rowGap;
    });

    currentY += sectionGap; // <-- extra space between section blocks
  }

  // --- 5. Assign node positions
  const buckets = d3.group(nodes, sectionOf, subOf);
  for (const [sec, subMap] of buckets) {
    for (const [sub, groupNodes] of subMap) {
      const y = posMap.get(`${sec}__${sub}`);
      if (sortInSublayer) groupNodes.sort(sortInSublayer);
      const domain = groupNodes.map(d => d.id ?? d.name);
      const xScale = d3.scalePoint(domain, [marginX, width - marginX]).padding(0.5);
      groupNodes.forEach(d => { d.x = xScale(d.id); d.y = y; });
    }
  }
}
    
  </script>
</body>
</html>
